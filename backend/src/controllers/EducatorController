const Educator = require("../models/Educator");
const Student = require("../models/Student");
const bcrypt = require("bcryptjs");
const crypto = require("crypto");
const nodemailer = require("nodemailer");
const PlatformReview = require("../models/PlatformReview");
const Feedback = require("../models/feedback.js");
const Class = require("../models/Class");
const ReportSchedule = require("../models/ReportSchedule");
const ChallengeSchedule = require("../models/ChallengeSchedule");
const ClassStudent = require("../models/ClassStudent");
const Challenge = require("../models/Challenge");
const { createBarChart } = require("../utils/chart");
const ChallengePerformance = require("../models/challengePerformance");
const QuizPerformance = require("../models/quizPerformance");


exports.login = async (req, res) => {
  try {
    const user = await Educator.findOne({ email: req.body.email });

    if (!user) {
      return res.json({ success: false, message: "User not found" });
    }

    if (user.status === "suspended") {
      return res.json({ 
        success: false, 
        message: "Your account was suspended. Please contact your admin to reactivate." 
      });
    }

    const isMatch = await bcrypt.compare(req.body.password, user.password);

    if (!isMatch) {
      return res.json({ success: false, message: "Incorrect password" });
    }

    // store user info in session
    req.session.user = {
      id: user._id.toString(),
      fullname: user.fullname
    };

    // Success
    return res.json({ success: true, message: "Login successful!" });

  } catch (err) {
    console.error(err);
    return res.json({ success: false, message: "Server error" });
  }
};

exports.logout = (req, res) => {
  req.session.destroy((err) => {
    if (err) {
      console.error(err);
      return res.redirect("/educator/login");
    }

    res.clearCookie("connect.sid");
    return res.redirect("/educator/login");
  });
};

exports.forgotPassword = async (req, res) => {
  const { email } = req.body;

  const user = await Educator.findOne({ email });
  if (!user) return res.send("No user with this email");

  const token = crypto.randomBytes(20).toString("hex");

  user.resetPasswordToken = crypto
    .createHash("sha256")
    .update(token)
    .digest("hex");

  user.resetPasswordExpire = Date.now() + 10 * 60 * 1000; // 10 min
  await user.save();

  const resetUrl = `http://localhost:3000/educator/reset-password/${token}`;
  

  // --------- Nodemailer setup ----------
  const transporter = nodemailer.createTransport({
    service: "gmail",
    auth: {
      user: process.env.EMAIL_USER, // your email
      pass: process.env.EMAIL_PASS  // your app password (or real password)
    }
  });

  const mailOptions = {
    from: process.env.EMAIL_USER,
    to: user.email,
    subject: "Password Reset",
    html: `<p>You requested a password reset</p>
           <p>Click this link to reset your password:</p>
           <a href="${resetUrl}">${resetUrl}</a>
           <p>This link expires in 10 minutes.</p>`
  };

  try {
    await transporter.sendMail(mailOptions);
     return res.json({
      success: true,
      message: "Reset link sent to your email ✅"
    });

  } catch (err) {
    console.error(err);
    return res.json({
      success: false,
      message: "Reset failed ❌"
    });
  }
};
// ==================
// RESET PASSWORD
// ==================
exports.resetPassword = async (req, res) => {
  const token = req.body.token || req.params.token; // get token from hidden input or URL
  const hashedToken = crypto.createHash("sha256").update(token).digest("hex");

  const user = await Educator.findOne({
    resetPasswordToken: hashedToken,
    resetPasswordExpire: { $gt: Date.now() }
  });

  if (!user) return res.send("Token invalid or expired ❌");

  const salt = await bcrypt.genSalt(10);
  user.password = await bcrypt.hash(req.body.password, salt);

  user.resetPasswordToken = undefined;
  user.resetPasswordExpire = undefined;

  await user.save();

  return res.json({
      success: true,
      message: "Password reset successfully ✅"
    });
};


exports.profile = async (req, res) => {
  try {
    // Make sure user is logged in
    if (!req.session.user) {
      return res.redirect("/educator/login");
    }

    // Get fresh data from DB
    const educator = await Educator.findById(req.session.user.id)
      .select("-password");

    if (!educator) {
      return res.status(404).send("User not found");
    }

    res.render("educatorprofile", {
      educator   // <-- IMPORTANT (matches your HBS)
    });

  } catch (err) {
    console.error(err);
    res.status(500).send("Error loading profile");
  }
};

exports.info = async (req, res) => {
  try {
    // Make sure user is logged in
    if (!req.session.user) {
      return res.redirect("/educator/login");
    }

    // Get fresh data from DB
    const educator = await Educator.findById(req.session.user.id)
      .select("-password");

    if (!educator) {
      return res.status(404).send("User not found");
    }

    res.render("educatordashboard", {
      educator   // <-- IMPORTANT (matches your HBS)
    });

  } catch (err) {
    console.error(err);
    res.status(500).send("Error loading profile");
  }
};



exports.platformReview = async (req, res) => {
  try {
    const fullname=req.session.user.fullname;
    const { content, rating, tags } = req.body;

    const review = new PlatformReview({
      fullname,
      content,
      rating,
      tags
    });

    await review.save();
    return res.json({ success: true, message: "Platform review submitted ✅" });
  } catch (err) {
    console.error(err);
    res.status(500).send("Failed to submit review");
  }
};

exports.updateCredential = async (req, res) => {
  try {
    if (!req.session.user) {
      return res.redirect("/login");
    }

    // Destructure all possible fields from request body
    const { fullname, displayname, department, subject, password } = req.body;

    // Build update object dynamically
    const updateData = {};
    if (fullname) updateData.fullname = fullname;
    if (displayname) updateData.displayname = displayname;
    if (department) updateData.department = department;
    if (subject) updateData.subject = subject;

    // Hash password if provided
    if (password) {
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(password, salt);
      updateData.password = hashedPassword;
    }

    const updatedEducator = await Educator.findByIdAndUpdate(
      req.session.user.id,
      updateData,
      { new: true } // return updated document
    );

    // Update session with only the changed fields
    req.session.user = { ...req.session.user, ...updateData };

    res.json({ message: "Credentials updated successfully ✅", success: true });

  } catch (err) {
    console.error(err);
    res.status(500).send("Error updating profile ❌");
  }
};


 exports.getFeedbacks = async (req, res) => {
    try {
      if (!req.session.user) {
      return res.redirect("/educator/login");
    }

    const educatorId = req.session.user.id;

    // Find feedbacks for this educator and populate student name
    const feedbacks = await Feedback.find({ educatorId,reply: null })
      .populate({
        path: "studentId",     // replace studentId with student document
        select: "fullname"     // only get fullname field
      })
      .sort({ createdAt: -1 }); // optional: latest first

    // Map to send student name instead of full object
    const result = feedbacks.map(fb => ({
      _id: fb._id,
      studentName: fb.studentId.fullname, // populated name
      feedback: fb.feedback,
      reply: fb.reply,
      createdAt: fb.createdAt,
      repliedAt: fb.repliedAt
    }));

    res.json(result);
  } catch (err) {
    console.error(err);
    res.status(500).send("Error fetching feedbacks");
  }
};

  
exports.replyFeedback = async (req, res) => {
  try {
    const { feedbackId } = req.params;  // get the ID from URL
    const { reply } = req.body;          // get the reply from the form

    // Update the feedback
    const updated = await Feedback.findByIdAndUpdate(
      feedbackId,
      { reply: reply, repliedAt: new Date() }
    );

    if (!updated) {
      return res.status(404).send("Feedback not found");
    }

    res.redirect("/educator/dashboard"); // or wherever you want to redirect
  } catch (err) {
    console.error(err);
    res.status(500).send("Error replying to feedback");
  }
};



exports.manageClass = async (req, res) => {
  try {
    const educatorId = req.session.user.id;

    const classes = await Class.find({ educatorId });

    res.json(classes);
  } catch (err) {
    res.status(500).json({ message: "Server error" });
  }
};

 


exports.generateStudentReport = async (req, res) => {
  try {
    
    const {
      classId,
      studentID,
      reportType,   // overview / quizPerformance / challengePerformance
      timeRange,
      customStart,
      customEnd,
    } = req.body;

    // ----- Time filter -----
    let startDate, endDate;
    const now = new Date();

    if (timeRange === "thisweek") {
      startDate = new Date(now);
      startDate.setDate(startDate.getDate() - 7);
      endDate = new Date();
    } 
    else if (timeRange === "thismonth") {
      startDate = new Date(now.getFullYear(), now.getMonth(), 1);
      endDate = new Date();
    }
    else if (timeRange === "30days") {
      startDate = new Date(now);
      startDate.setDate(startDate.getDate() - 30);
      endDate = new Date();
    }
    else if (timeRange === "thisterm") {
  const classData = await Class.findById(classId);
  startDate = classData.termStartDate; // from class collection
  endDate = classData.termEndDate;     // from class collection
}
    else if (timeRange === "custom") {
      startDate = new Date(customStart);
      endDate = new Date(customEnd);
    }

    const report = {
      main: null,
      chart: null,
      summary: {}
    };

    // ----- OVERVIEW REPORT -----
    if (reportType === "overview") {

      const quizData = await QuizPerformance.find({
        studentId: studentID,
        classId: classId,
        createdAt: { $gte: startDate, $lte: endDate }
      });

      const challengeData = await ChallengePerformance.find({
        studentId: studentID,
        classId: classId,
        createdAt: { $gte: startDate, $lte: endDate }
      });

      const combined = [...quizData, ...challengeData].sort(
        (a, b) => new Date(a.createdAt) - new Date(b.createdAt)
      );

      // Aggregate XP & Coins by date
      const xpByDateMap = {};
      combined.forEach(r => {
        const date = new Date(r.createdAt).toISOString().split("T")[0];
        if (!xpByDateMap[date]) xpByDateMap[date] = { totalXP: 0, totalCoins: 0 };
        xpByDateMap[date].totalXP += r.xp || 0;
        xpByDateMap[date].totalCoins += r.coins || 0;
      });

      const labels = Object.keys(xpByDateMap);
      const dataXP = labels.map(d => xpByDateMap[d].totalXP);

      report.chart = await createBarChart(labels, dataXP, "Total XP Over Time");

      report.summary.totalXP = combined.reduce((sum, r) => sum + (r.xp || 0), 0);
      report.summary.totalCoins = combined.reduce((sum, r) => sum + (r.coins || 0), 0);
      report.summary.totalQuiz = quizData.length;
      report.summary.totalChallenge = challengeData.length;

      report.main = combined; // full quiz + challenge data for frontend

    }

    // ----- QUIZ PERFORMANCE -----
    else if (reportType === "quizPerformance") {
      const quizData = await QuizPerformance.find({
        studentId: studentID,
        classId: classId,
        createdAt: { $gte: startDate, $lte: endDate }
      });

      report.main = quizData;

      const scores = quizData.map(q => q.score);
      const labels = quizData.map((q, i) => q.title || `Quiz ${i + 1}`);

      report.chart = await createBarChart(labels, scores, "Quiz Performance");

      report.summary.totalXP = quizData.reduce((sum, q) => sum + (q.xp || 0), 0);
      report.summary.totalCoins = quizData.reduce((sum, q) => sum + (q.coins || 0), 0);
      report.summary.attempts = quizData.length;
      report.summary.highestScore = Math.max(...scores);
      report.summary.lowestScore = Math.min(...scores);
      report.summary.averageScore = scores.reduce((a, b) => a + b, 0) / (scores.length || 1);
    }

    // ----- CHALLENGE PERFORMANCE -----
    else if (reportType === "challengePerformance") {
      const challengeData = await ChallengePerformance.find({
        studentId: studentID,
        classId: classId,
        createdAt: { $gte: startDate, $lte: endDate }
      });

      report.main = challengeData;

      const scores = challengeData.map(c => c.score);
      const labels = challengeData.map((c, i) => c.title || `Challenge ${i + 1}`);

      report.chart = await createBarChart(labels, scores, "Challenge Performance");

      report.summary.totalXP = challengeData.reduce((sum, c) => sum + (c.xp || 0), 0);
      report.summary.totalCoins = challengeData.reduce((sum, c) => sum + (c.coins || 0), 0);
      report.summary.attempts = challengeData.length;
      report.summary.highestScore = Math.max(...scores);
      report.summary.lowestScore = Math.min(...scores);
      report.summary.averageScore = scores.reduce((a, b) => a + b, 0) / (scores.length || 1);
    }

    res.json({
  success: true,
  chart: report.chart, // this must be a string starting with 'data:image/png;base64,'
  summary: report.summary,
  main: report.main
});
  } catch (err) {
    console.error("Backend Error:", err);
    return res.status(500).json({ success: false, message: err.message });
  }
};

exports.generateClassReport = async (req, res) => {
  try {
    const {
      classId,
      reportType,   // overview / quizPerformance / challengePerformance
      timeRange,
      customStart,
      customEnd,
    } = req.body;

    // ----- Time filter -----
    let startDate, endDate;
    const now = new Date();

    if (timeRange === "thisweek") {
      startDate = new Date(now);
      startDate.setDate(startDate.getDate() - 7);
      endDate = new Date();
    } 
    else if (timeRange === "thismonth") {
      startDate = new Date(now.getFullYear(), now.getMonth(), 1);
      endDate = new Date();
    }
    else if (timeRange === "30days") {
      startDate = new Date(now);
      startDate.setDate(startDate.getDate() - 30);
      endDate = new Date();
    }
    else if (timeRange === "thisterm") {
  const classData = await Class.findById(classId);
  startDate = classData.termStartDate; // from class collection
  endDate = classData.termEndDate;     // from class collection
}
    else if (timeRange === "custom") {
      startDate = new Date(customStart);
      endDate = new Date(customEnd);
    }

    const report = {
      main: null,
      chart: null,
      summary: {}
    };

    // ----- OVERVIEW REPORT -----
    if (reportType === "overview") {

      const quizData = await QuizPerformance.find({
        
        classId: classId,
        createdAt: { $gte: startDate, $lte: endDate }
      });

      const challengeData = await ChallengePerformance.find({
        
        classId: classId,
        createdAt: { $gte: startDate, $lte: endDate }
      });

      const combined = [...quizData, ...challengeData].sort(
        (a, b) => new Date(a.createdAt) - new Date(b.createdAt)
      );

      // Aggregate XP & Coins by date
      const xpByDateMap = {};
      combined.forEach(r => {
        const date = new Date(r.createdAt).toISOString().split("T")[0];
        if (!xpByDateMap[date]) xpByDateMap[date] = { totalXP: 0, totalCoins: 0 };
        xpByDateMap[date].totalXP += r.xp || 0;
        xpByDateMap[date].totalCoins += r.coins || 0;
      });

      const labels = Object.keys(xpByDateMap);
      const dataXP = labels.map(d => xpByDateMap[d].totalXP);

      report.chart = await createBarChart(labels, dataXP, "Total XP Over Time");

      report.summary.totalXP = combined.reduce((sum, r) => sum + (r.xp || 0), 0);
      report.summary.totalCoins = combined.reduce((sum, r) => sum + (r.coins || 0), 0);
      report.summary.totalQuiz = quizData.length;
      report.summary.totalChallenge = challengeData.length;

      report.main = combined; // full quiz + challenge data for frontend

    }

    // ----- QUIZ PERFORMANCE -----
    else if (reportType === "quizPerformance") {
      const quizData = await QuizPerformance.find({
        
        classId: classId,
        createdAt: { $gte: startDate, $lte: endDate }
      });

      report.main = quizData;

      const scores = quizData.map(q => q.score);
      const labels = quizData.map((q, i) => q.title || `Quiz ${i + 1}`);

      report.chart = await createBarChart(labels, scores, "Quiz Performance");

      report.summary.totalXP = quizData.reduce((sum, q) => sum + (q.xp || 0), 0);
      report.summary.totalCoins = quizData.reduce((sum, q) => sum + (q.coins || 0), 0);
      report.summary.attempts = quizData.length;
      report.summary.highestScore = Math.max(...scores);
      report.summary.lowestScore = Math.min(...scores);
      report.summary.averageScore = scores.reduce((a, b) => a + b, 0) / (scores.length || 1);
    }

    // ----- CHALLENGE PERFORMANCE -----
    else if (reportType === "challengePerformance") {
      const challengeData = await ChallengePerformance.find({
        
        classId: classId,
        createdAt: { $gte: startDate, $lte: endDate }
      });

      report.main = challengeData;

      const scores = challengeData.map(c => c.score);
      const labels = challengeData.map((c, i) => c.title || `Challenge ${i + 1}`);

      report.chart = await createBarChart(labels, scores, "Challenge Performance");

      report.summary.totalXP = challengeData.reduce((sum, c) => sum + (c.xp || 0), 0);
      report.summary.totalCoins = challengeData.reduce((sum, c) => sum + (c.coins || 0), 0);
      report.summary.attempts = challengeData.length;
      report.summary.highestScore = Math.max(...scores);
      report.summary.lowestScore = Math.min(...scores);
      report.summary.averageScore = scores.reduce((a, b) => a + b, 0) / (scores.length || 1);
    }

    res.json({
  success: true,
  chart: report.chart, // this must be a string starting with 'data:image/png;base64,'
  summary: report.summary,
  main: report.main
});
  } catch (err) {
    console.error("Backend Error:", err);
    return res.status(500).json({ success: false, message: err.message });
  }
};

exports.getClass =async (req, res) => {
  try {
    const classes = await Class.find({}, '_id name'); // only return _id and name
    res.json(classes); 
  } catch (err) {
    res.status(500).json({ message: 'Failed to fetch classes' });
  }
};

exports.getStudent =async (req, res) => {
try {
    const { classId } = req.params;
    

    const classStudents = await ClassStudent.find({ classId }).populate("studentId");
    

    // Only map those with studentId populated
    const students = classStudents
      .filter(cs => cs.studentId)  // skip null
      .map(cs => ({
        id: cs.studentId._id,
        name: cs.studentId.fullname
      }));

    res.json(students);
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: "Failed to load students" });
  }
};

exports.sendReportEmail = async (req, res) => {
  try {
    const {
      classId,
      studentID,
      reportType,   // overview / quizPerformance / challengePerformance
      timeRange,
      customStart,
      customEnd
    } = req.body;

    // ----- TIME FILTER -----
    let startDate, endDate;
    const now = new Date();

    if (timeRange === "thisweek") {
      startDate = new Date(now); startDate.setDate(startDate.getDate() - 7);
      endDate = new Date();
    } else if (timeRange === "thismonth") {
      startDate = new Date(now.getFullYear(), now.getMonth(), 1);
      endDate = new Date();
    } else if (timeRange === "30days") {
      startDate = new Date(now); startDate.setDate(startDate.getDate() - 30);
      endDate = new Date();
    } else if (timeRange === "thisterm") {
      const classData = await Class.findById(classId);
      if (!classData) return res.status(404).json({ message: "Class not found" });
      startDate = classData.termStartDate;
      endDate = classData.termEndDate;
    } else if (timeRange === "custom") {
      startDate = new Date(customStart);
      endDate = new Date(customEnd);
    }

    // ----- FETCH DATA & GENERATE REPORT -----
    const report = { main: null, chart: null, summary: {} };

    if (reportType === "overview") {
      const quizData = await QuizPerformance.find({
        studentId: studentID,
        classId,
        createdAt: { $gte: startDate, $lte: endDate }
      });

      const challengeData = await ChallengePerformance.find({
        studentId: studentID,
        classId,
        createdAt: { $gte: startDate, $lte: endDate }
      });

      const combined = [...quizData, ...challengeData].sort(
        (a, b) => new Date(a.createdAt) - new Date(b.createdAt)
      );

      // Aggregate XP & Coins by date
      const xpByDateMap = {};
      combined.forEach(r => {
        const date = new Date(r.createdAt).toISOString().split("T")[0];
        if (!xpByDateMap[date]) xpByDateMap[date] = { totalXP: 0, totalCoins: 0 };
        xpByDateMap[date].totalXP += r.xp || 0;
        xpByDateMap[date].totalCoins += r.coins || 0;
      });

      const labels = Object.keys(xpByDateMap);
      const dataXP = labels.map(d => xpByDateMap[d].totalXP);
      report.chart = await createBarChart(labels, dataXP, "Total XP Over Time");

      report.summary.totalXP = combined.reduce((sum, r) => sum + (r.xp || 0), 0);
      report.summary.totalCoins = combined.reduce((sum, r) => sum + (r.coins || 0), 0);
      report.summary.totalQuiz = quizData.length;
      report.summary.totalChallenge = challengeData.length;
      report.main = combined;
    } 
    else if (reportType === "quizPerformance") {
      const quizData = await QuizPerformance.find({
        studentId: studentID,
        classId,
        createdAt: { $gte: startDate, $lte: endDate }
      });

      report.main = quizData;

      const scores = quizData.map(q => q.score);
      const labels = quizData.map((q, i) => q.title || `Quiz ${i + 1}`);
      report.chart = await createBarChart(labels, scores, "Quiz Performance");

      report.summary.totalXP = quizData.reduce((sum, q) => sum + (q.xp || 0), 0);
      report.summary.totalCoins = quizData.reduce((sum, q) => sum + (q.coins || 0), 0);
      report.summary.attempts = quizData.length;
      report.summary.highestScore = Math.max(...scores);
      report.summary.lowestScore = Math.min(...scores);
      report.summary.averageScore = scores.reduce((a, b) => a + b, 0) / (scores.length || 1);
    } 
    else if (reportType === "challengePerformance") {
      const challengeData = await ChallengePerformance.find({
        studentId: studentID,
        classId,
        createdAt: { $gte: startDate, $lte: endDate }
      });

      report.main = challengeData;

      const scores = challengeData.map(c => c.score);
      const labels = challengeData.map((c, i) => c.title || `Challenge ${i + 1}`);
      report.chart = await createBarChart(labels, scores, "Challenge Performance");

      report.summary.totalXP = challengeData.reduce((sum, c) => sum + (c.xp || 0), 0);
      report.summary.totalCoins = challengeData.reduce((sum, c) => sum + (c.coins || 0), 0);
      report.summary.attempts = challengeData.length;
      report.summary.highestScore = Math.max(...scores);
      report.summary.lowestScore = Math.min(...scores);
      report.summary.averageScore = scores.reduce((a, b) => a + b, 0) / (scores.length || 1);
    }

    // ----- GET STUDENT -----
    const student = await Student.findById(studentID).select("fullname email");
    if (!student) return res.status(404).json({ message: "Student not found" });

    // ----- CHART BUFFER -----
    const base64Data = report.chart.replace(/^data:image\/png;base64,/, "");
    const buffer = Buffer.from(base64Data, "base64");

    // ----- EMAIL TRANSPORTER -----
    const transporter = nodemailer.createTransport({
      service: "gmail",
      auth: { user: process.env.EMAIL_USER, pass: process.env.EMAIL_PASS }
    });

    // ----- BUILD SUMMARY HTML -----
    let summaryHtml = "";
    for (const key in report.summary) {
      summaryHtml += `
        <div style="padding:10px; margin-bottom:10px; border-radius:10px; background-color:#e0f2ff;">
          <span style="font-size:10px; font-weight:bold; text-transform:uppercase;">
            ${key.replace(/([A-Z])/g, " $1")}
          </span>
          <div style="font-size:24px; font-weight:bold;">${report.summary[key]}</div>
        </div>
      `;
    }

    // ----- MAIL OPTIONS -----
    const mailOptions = {
      from: process.env.EMAIL_USER,
      to: student.email,
      subject: "Your Performance Report",
      html: `
        <h2>Hello ${student.fullname},</h2>
        <p>Here is your performance report:</p>
        ${summaryHtml}
        <p>See attached chart:</p>
      `,
      attachments: [
        { filename: "report.png", content: buffer, contentType: "image/png" }
      ]
    };

    // ----- SEND EMAIL -----
    await transporter.sendMail(mailOptions);

    // ----- RESPONSE -----
    res.json({ success: true, message: "Report generated and email sent successfully" });

  } catch (err) {
    console.error("SEND REPORT ERROR:", err);
    res.status(500).json({ success: false, message: "Failed to generate/send report" });
  }
};



exports.scheduleReport = async (req, res) => {
  try {
    const { runAt } = req.body;

    const schedule = await ReportSchedule.create({
      runAt: new Date(runAt),
      educatorId: req.session.user.id
    });

    res.json({
      message: "Report scheduled",
      scheduleId: schedule._id
    });
  } catch (err) {
    res.status(500).json({ message: "Failed to schedule report" });
  }
};

 



 exports.scheduleChallenge = async (req, res) => {
  try {
    const { challengeId, startAt, endAt } = req.body;

    // ✅ Basic validation (prevents 500)
    if (!challengeId || !startAt || !endAt) {
      return res.status(400).json({
        message: "Missing challengeId, startAt or endAt"
      });
    }

     const result = await ChallengeSchedule.findOneAndUpdate(
      { challengeId: challengeId }, // find by challengeId
      {
        startDate: new Date(startAt),
        endDate: new Date(endAt)
      },
      { upsert: true, new: true, setDefaultsOnInsert: true } // create if not found
    );

    res.json({ message: "Challenge scheduled successfully" });
  } catch (err) {
    console.error("SCHEDULE ERROR:", err);
    res.status(500).json({ message: "Failed to schedule challenge" });
  }
};


exports.challengeAvailable = async (req, res) => {
  await Challenge.updateOne(
    { _id: req.params.challengeID },
    { status: "available" }
  );
  res.json({ message: "Challenge is now available" });
};

  
exports.challengeUnavailable = async (req, res) => {
  await Challenge.updateOne(
    { _id: req.params.challengeID },
    { status: "unavailable" }
  );
  res.json({ message: "Challenge is now unavailable" });
};

